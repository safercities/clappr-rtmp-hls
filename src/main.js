// Copyright 2014 Globo.com Player authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

var Playback = require('playback')
var assign = require('lodash.assign')
var template = require('template')
//var uniqueId = require('utils').uniqueId //TODO: actually use the uniqueID generator

var RTMP = require('./rtmp.js');

var Mediator = require('mediator')
var Browser = require('browser')
var Events = require('events')

var JST = require('./rtmp_jst') //TODO: bring all of the templates into here, generated by bin/hook

var $ = require('zepto')

var HLSEvents = require('./flashls_events')

var objectIE = '<object type="application/x-shockwave-flash" id="<%= cid %>" class="hls-playback" classid="clsid:d27cdb6e-ae6d-11cf-96b8-444553540000" data-hls="" width="100%" height="100%"><param name="movie" value="<%= baseUrl %>/assets/HLSPlayer.swf"> <param name="quality" value="autohigh"> <param name="swliveconnect" value="true"> <param name="allowScriptAccess" value="always"> <param name="bgcolor" value="#001122"> <param name="allowFullScreen" value="false"> <param name="wmode" value="transparent"> <param name="tabindex" value="1"> <param name=FlashVars value="playbackId=<%= playbackId %>" /> </object>'

class RtmpHls extends Playback {
  get name() { return 'rtmp_hls' }
  get tagName() { return 'div' }
  //Template copied from HLS in clappr
  get hlsTemplate() { return template('<object class="hls-playback" data-hls type="application/x-shockwave-flash" width="100%" height="100"><param name="movie" value="<%= baseUrl %>/assets/HLSPlayer.swf?inline=1"><param name="quality" value="autohigh"><param name="swliveconnect" value="true"><param name="allowScriptAccess" value="always"><param name="bgcolor" value="#001122"><param name="allowFullScreen" value="false"><param name="wmode" value="transparent"><param name="tabindex" value="1"><param name=FlashVars value="playbackId=<%= playbackId %>&callback=<%= callbackName %>" /><embed type="application/x-shockwave-flash" tabindex="1" enablecontextmenu="false" allowScriptAccess="always" quality="autohigh" pluginspage="http://www.macromedia.com/go/getflashplayer" wmode="transparent" swliveconnect="true" type="application/x-shockwave-flash" allowfullscreen="false" bgcolor="#000000" FlashVars="playbackId=<%= playbackId %>&callback=<%= callbackName %>" src="<%= baseUrl %>/assets/HLSPlayer.swf" width="100%" height="100%"></embed></object>') }
  get rtmpTemplate() { return JST.rtmp }
  get clapprId() { return this.cid }
  get attributes() {
    return {
      'class': 'rtmpHlsContainer',
      'style': 'height: 100%;'
    }
  }

  constructor(options) {
    super(options)

    this.options = options
    this.src = options.hls.src //Set this just in case - what happens if we remove it?

    //TODO: this is a hack.
    this.uniqueIdStart = 100;
    this.hlsCid = 'c'+(++this.uniqueIdStart);
    this.hlsUniqueId = 'o'+(++this.uniqueIdStart);
    this.rtmpCid = 'c'+(++this.uniqueIdStart);
    this.rtmpUniqueId = 'o'+(++this.uniqueIdStart);

    this.bootstrapCount = 0

    //HLS Options
    this.hls = {}
    this.hls.baseUrl = options.baseUrl;
    this.hls.flushLiveURLCache = (options.hls.flushLiveURLCache === undefined) ? true : options.hls.flushLiveURLCache
    this.hls.capLevelToStage = (options.hls.capLevelToStage === undefined) ? false : options.hls.capLevelToStage
    this.hls.useHardwareVideoDecoder = (options.hls.useHardwareVideoDecoder === undefined) ? !Browser.isChrome : options.hls.useHardwareVideoDecoder
    this.hls.maxBufferLength = (options.hls.maxBufferLength === undefined) ? 120 : options.hls.maxBufferLength
    this.hls.hlsMinimumDvrSize = (options.hls.hlsMinimumDvrSize == undefined) ? 60 : options.hls.hlsMinimumDvrSize

    //RTMP Options
    this.rtmp = {}
    this.rtmp.src = options.rtmp.src
    this.rtmp.baseUrl = options.baseUrl;
    this.rtmp.swfPath = "/assets/RTMP.swf"

    //General player options
    this.highDefinition = false
    this.autoPlay = options.autoPlay
    this.defaultSettings = {
      left: ["playstop"],
      default: ['seekbar'],
      right: ["fullscreen"],
      seekEnabled: false
    }

    this.playbackType = 'live'
    this.settings.seekEnabled = true //Should always be true

    this.settings = assign({}, this.defaultSettings)
    //this.trigger(Events.PLAYBACK_SETTINGSUPDATE)

    this.addListeners()
  }

  addListeners() {
  	//HLS
    Mediator.on(this.hlsCid + ':flashready', () => this.bootstrap())
    Mediator.on(this.hlsCid + ':timeupdate', (timeMetrics) => this.updateTime(timeMetrics))
    
    //RTMP
    Mediator.on(this.rtmpUniqueId + ':flashready', this.bootstrap, this)
  }


  addHlsListeners(){
  	
    Mediator.on(this.hlsCid + ':playbackstate', (state) => this.setPlaybackState(state))
    Mediator.on(this.hlsCid + ':levelchanged', (level) => this.updateHighDefinition(level))
    Mediator.on(this.hlsCid + ':playbackerror', () => this.flashPlaybackError())
  }

  removeHlsListeners(){
  	//Mediator.off(this.hlsCid + ':timeupdate')
    Mediator.off(this.hlsCid + ':playbackstate')
    Mediator.off(this.hlsCid + ':levelchanged')
    Mediator.off(this.hlsCid + ':playbackerror')
  }

  addRtmpListeners(){
  	Mediator.on(this.rtmpUniqueId + ':progress', this.rtmpProgress, this)
    Mediator.on(this.rtmpUniqueId + ':timeupdate', this.rtmpUpdateTime, this)
    Mediator.on(this.rtmpUniqueId + ':statechanged', this.rtmpCheckState, this)
  }

  removeRtmpListeners(){
  	Mediator.off(this.rtmpUniqueId + ':progress')
    Mediator.off(this.rtmpUniqueId + ':timeupdate')
    Mediator.off(this.rtmpUniqueId + ':statechanged')
  }


  stopListening() {
    super.stopListening()

    //HLS
    Mediator.off(this.hlsCid + ':flashready')
    Mediator.off(this.hlsCid + ':timeupdate')
    Mediator.off(this.hlsCid + ':playbackstate')
    Mediator.off(this.hlsCid + ':levelchanged')
    Mediator.off(this.hlsCid + ':playbackerror')

    //RTMP
    Mediator.off(this.rtmpUniqueId + ':progress')
    Mediator.off(this.rtmpUniqueId + ':timeupdate')
    Mediator.off(this.rtmpUniqueId + ':statechanged')
    Mediator.off(this.rtmpUniqueId + ':flashready')
  }


  bootstrap() {

  	if(++this.bootstrapCount != 2) return; //Wait for the other player to bootstrap

    this.el.width = "100%"
    this.el.height = "100%"
    this.isReady = true
    this.srcLoaded = false
    this.currentState = "IDLE"
    this.setHlsFlashSettings()

    this.updatePlaybackType()
    
    this.addRtmpListeners()
    $(this.hlsEl).css('display', 'hidden')

    this.autoPlay && this.play()
    this.trigger(Events.PLAYBACK_READY, this.name)
  }

  changePlayer(newPlayer){
  	this.currentPlayer = newPlayer
  	if(newPlayer == 'RTMP'){
  		this.$hlsEl.css('visibility', 'hidden')
  		this.$rtmpEl.css('visibility', 'visible')
  		this.hlsEl.playerStop()
  		this.removeHlsListeners()
  		this.addRtmpListeners()
  		this.play()
  		//this.rtmpEl.playerPlay(this.rtmp.src)
  		//this.hlsEl.playerStop()
    	//this.currentState = "PLAYING"

    	//this.hlsEl.playerLoad(this.options.hls.src)
    	//Mediator.on(this.hlsCid + ':manifestloaded', this.manifestRefreshed, this)
  	}else{
  		this.$hlsEl.css('visibility', 'visible')
  		this.$rtmpEl.css('visibility', 'hidden')
  		this.rtmpEl.playerPause()
  		this.removeRtmpListeners()
  		
  		this.addHlsListeners()

  	}

  	
  }

  setHlsFlashSettings() {
    this.hlsEl.playerSetflushLiveURLCache(this.hls.flushLiveURLCache)
    this.hlsEl.playerCapLeveltoStage(this.hls.capLevelToStage)
    this.hlsEl.playerSetmaxBufferLength(this.hls.maxBufferLength)
    this.hlsEl.playerSetUseHardwareVideoDecoder(this.hls.useHardwareVideoDecoder)
  }

  updateHighDefinition(level) {
    var currentLevel = this.getLevels()[level]
    this.highDefinition = (currentLevel.height >= 720 || (currentLevel.bitrate / 1000) >= 2000);
    this.trigger(Events.PLAYBACK_HIGHDEFINITIONUPDATE)
    this.trigger(Events.PLAYBACK_BITRATE, {'bitrate': this.getCurrentBitrate()})
  }

  updateTime(timeMetrics) {
    if (this.currentState === 'IDLE') return

    var duration = this.normalizeDuration(timeMetrics.duration)
    var position = Math.min(Math.max(timeMetrics.position, 0), duration)
    var previousDVRStatus = this.dvrEnabled
    var livePlayback = (this.playbackType === 'live')
    this.dvrEnabled = (livePlayback && duration > this.hls.hlsMinimumDvrSize)
        //console.log(this.playbackType, duration, this.hls.hlsMinimumDvrSize)
    if (duration === 100 || livePlayback === undefined) {
      return;
    }

    if (this.dvrEnabled !== previousDVRStatus) {
      this.updateSettings()
      this.trigger(Events.PLAYBACK_SETTINGSUPDATE, this.name)
    }

    if (livePlayback && (!this.dvrEnabled || !this.dvrInUse)) {
      position = duration
    }

    this.trigger(Events.PLAYBACK_TIMEUPDATE, position, duration, this.name)
  }

  play() {

  	if (!this.srcLoaded && this.currentState !== "PLAYING") return this.firstPlay()

  	switch(this.currentPlayer){
  		case 'RTMP':
		    this.rtmpEl.playerResume()
		    this.trigger(Events.PLAYBACK_PLAY, this.name)

		    console.log('playing')
  			break;

  		case 'HLS':
  			if(this.currentState === 'PAUSED') {
				this.hlsEl.playerResume()
			} else {
				this.hlsEl.playerPlay()
			}
  			break;
  	}
  }

  getPlaybackType() {
    return this.playbackType? this.playbackType: null
  }

  getCurrentBitrate() {
    var currentLevel = this.getLevels()[this.hlsEl.getLevel()]
    return currentLevel.bitrate
  }

  isHighDefinitionInUse() {
    return this.highDefinition
  }

  getLevels() {
    if (!this.levels || this.levels.length === 0) {
      this.levels = this.hlsEl.getLevels()
    }
    return this.levels
  }

  rtmpCheckState() {
  	if(this.currentPlayer == 'HLS') return

    if (this.currentState === "PAUSED") {
      return
    } else if (this.currentState !== "PLAYING_BUFFERING" && this.rtmpEl.getState() === "PLAYING_BUFFERING") {
      this.trigger(Events.PLAYBACK_BUFFERING, this.name)
      this.currentState = "PLAYING_BUFFERING"
    } else if (this.rtmpEl.getState() === "PLAYING") {
      this.trigger(Events.PLAYBACK_BUFFERFULL, this.name)
      this.currentState = "PLAYING"
    } else if (this.rtmpEl.getState() === "IDLE") {
      this.currentState = "IDLE"
    } else if (this.rtmpEl.getState() === "ENDED") {
      this.trigger(Events.PLAYBACK_ENDED, this.name)
      this.trigger(Events.PLAYBACK_TIMEUPDATE, 0, this.rtmpEl.getDuration(), this.name)
      this.currentState = "ENDED"
    }
  }

  rtmpProgress() {
    if (this.currentState !== "IDLE" && this.currentState !== "ENDED") {
      //this.trigger(Events.PLAYBACK_PROGRESS, 0, this.rtmpEl.getBytesLoaded(), this.rtmpEl.getBytesTotal(), this.name)
    }
  }

  rtmpUpdateTime() {
    //this.trigger(Events.PLAYBACK_TIMEUPDATE, this.rtmpEl.getPosition(), this.rtmpEl.getDuration(), this.name)
  }

  setPlaybackState(state) {
  	if(this.currentPlayer == 'RTMP') return

    if (["PLAYING_BUFFERING", "PAUSED_BUFFERING"].indexOf(state) >= 0)  {
      this.trigger(Events.PLAYBACK_BUFFERING, this.name)
      this.updateCurrentState(state)
    } else if (["PLAYING", "PAUSED"].indexOf(state) >= 0) {
      if (["PLAYING_BUFFERING", "PAUSED_BUFFERING", "IDLE"].indexOf(this.currentState) >= 0) {
        this.trigger(Events.PLAYBACK_BUFFERFULL, this.name)
      }
      this.updateCurrentState(state)
    } else if (state === "IDLE") {
      this.updateCurrentState(state)
      this.trigger(Events.PLAYBACK_TIMEUPDATE, 0, this.hlsEl.getDuration(), this.name)
      this.trigger(Events.PLAYBACK_ENDED, this.name)
    }
  }

  updateCurrentState(state) {
    this.currentState = state
    this.updatePlaybackType()
    if (state === "PLAYING") {
      this.trigger(Events.PLAYBACK_PLAY, this.name)
    } else if (state === "PAUSED") {
      this.trigger(Events.PLAYBACK_PAUSE, this.name)
    }
  }

  updatePlaybackType() {
    this.playbackType = 'live' //TODO: HACK?! was this.hlsEl.getType()
    if (this.playbackType) {
      this.playbackType = this.playbackType.toLowerCase()
      if (this.playbackType === 'vod') {
        this.startReportingProgress()
      } else {
        this.stopReportingProgress()
      }
    }
    this.trigger(Events.PLAYBACK_PLAYBACKSTATE)
  }

  startReportingProgress() {
    if (!this.reportingProgress) {
      this.reportingProgress = true
      Mediator.on(this.hlsCid + ':fragmentloaded',() => this.onFragmentLoaded())
    }
  }

  stopReportingProgress() {
    Mediator.off(this.hlsCid + ':fragmentloaded', this.onFragmentLoaded, this)
  }

  onFragmentLoaded() {
    var buffered = this.hlsEl.getPosition() + this.hlsEl.getbufferLength()
    this.trigger(Events.PLAYBACK_PROGRESS, this.hlsEl.getPosition(), buffered, this.hlsEl.getDuration(), this.name)
  }


  manifestRefreshed(duration, loadmetrics) {
  	if(this.currentPlayer == 'HLS') return

  	console.log('manifestRefreshed', this.hlsEl.getDuration())

  	this.updateTime({
  		position: this.hlsEl.getDuration()-1, //Fake this, we're pretending we're at the end as we're using RTMP at the moment
  		duration: this.hlsEl.getDuration()
  	});

  	
  	var self = this
  	
  	window.setTimeout(function(){
  		if(self.currentPlayer == 'HLS') return;

  		self.hlsEl.playerStop();

  		self.hlsEl.playerLoad(self.options.hls.src);
  	}, 3000);

  }


  firstPlay() {
    this.setHlsFlashSettings() //ensure flushLiveURLCache will work (#327)

    this.rtmpEl.playerPlay(this.rtmp.src)
    this.currentState = "PLAYING"

    this.hlsEl.playerLoad(this.options.hls.src)
    Mediator.on(this.hlsCid + ':manifestloaded', this.manifestRefreshed, this)
    this.srcLoaded = true
  }

  volume(value) {
    if (this.isReady) {
      this.hlsEl.playerVolume(value)
    } else {
      this.listenToOnce(this, Events.PLAYBACK_BUFFERFULL, () => this.volume(value))
    }
  }

  pause() {
    if (this.playbackType !== 'live' || this.dvrEnabled) {
      this.hlsEl.playerPause()
      if (this.playbackType === 'live' && this.dvrEnabled) {
        this.updateDvr(true)
      }
    }
  }

  stop() {
    this.hlsEl.playerStop()
    this.trigger(Events.PLAYBACK_TIMEUPDATE, 0, this.name)
  }

  isPlaying() {
    if (this.currentState) {
      return !!(this.currentState.match(/playing/i))
    }
    return false
  }

  getDuration() {
    return this.normalizeDuration(this.hlsEl.getDuration())
  }

  normalizeDuration(duration) {
    return duration - 10
  }

  seek(time) {
    var duration = this.hlsEl.getDuration()
    if (time > 0) {
      time = duration * time / 100
    }

    // seek operations to a time within 5 seconds from live stream will position playhead back to live
    var dvrInUse = (time >= 0 && duration - time > 5)
    if (!dvrInUse) {
      this.changePlayer('RTMP');
      time = duration - 1
    }else{
    	console.log('SEEKING!!!')
      this.changePlayer('HLS');
      //this.hlsEl.playerStop();
      //this.hlsEl.playerLoad(this.options.hls.src);

       //Mediator.once(this.hlsCid + ':manifestloaded', function(){
       	//console.log('manifestloaded')
       	//this.hlsEl.playerPlay()
       	this.hlsEl.playerSeek(time)
	    this.trigger(Events.PLAYBACK_TIMEUPDATE, time, duration, this.name)
	    this.trigger(Events.PLAYBACK_HIGHDEFINITIONUPDATE)
       //}, this)

    }

    

    this.updateDvr(dvrInUse)
  }

  updateDvr(dvrInUse) {
    var previousDvrInUse = !!this.dvrInUse
    this.dvrInUse = dvrInUse
    if (this.dvrInUse !== previousDvrInUse) {
      this.updateSettings()
      this.trigger(Events.PLAYBACK_DVR, this.dvrInUse)
      this.trigger(Events.PLAYBACK_STATS_ADD, {'dvr': this.dvrInUse})
    }
  }

  flashPlaybackError() {
    this.trigger(Events.PLAYBACK_STOP)
  }

  timeUpdate(time, duration) {
    this.trigger(Events.PLAYBACK_TIMEUPDATE, time, duration, this.name)
  }

  destroy() {
    this.stopListening()
    this.$hlsEl.remove()
    this.$rtmpEl.remove()
  }

  updateSettings() {
    this.settings = assign({}, this.defaultSettings)
    if (this.playbackType === "vod" || this.dvrInUse) {
      this.settings.left = ["playpause", "position", "duration"]
      this.settings.seekEnabled = true
    } else if (this.dvrEnabled) {
      this.settings.left = ["playpause"]
      this.settings.seekEnabled = true
    } else {
      this.settings.seekEnabled = false
    }
  }

  setElement(element) {
    this.$el = element
    this.el = element[0]
  }

  createCallbacks() {
    if (!window.Clappr.flashlsCallbacks) {
      window.Clappr.flashlsCallbacks = {}
    }
    this.flashlsEvents = new HLSEvents(this.hlsCid)
    window.Clappr.flashlsCallbacks[this.hlsCid] = (eventName, args) => {
      this.flashlsEvents[eventName].apply(this.flashlsEvents, args)
    }
  }


	rtmpRender(){
		this.$rtmpEl = $(this.rtmpTemplate({ cid: this.rtmpCid, swfPath: this.rtmp.swfPath, playbackId: this.rtmpUniqueId }))
		if(Browser.isFirefox) {
			this.$rtmpEl.attr('data-flash', '')
		} else if (Browser.isLegacyIE) {
			this.$rtmpEl = $(template(objectIE)({ cid: this.rtmpCid, baseUrl: this.rtmp.baseUrl, playbackId: this.rtmpUniqueId }))
		}
		this.rtmpEl = this.$rtmpEl[0]
		this.$el.append(this.$rtmpEl)
	}

	hlsRender(){
		var style = [
			'<style class="clappr-style">',
			'[data-hls]{position:absolute;display:block;pointer-events:none;top:0;height:100%}',
			'</style>'
		].join('')

		this.$hlsEl = {}

		if(Browser.isLegacyIE) {
			this.$hlsEl = $(template(objectIE)({cid: this.hlsCid, baseUrl: this.rtmp.baseUrl, playbackId: this.hlsUniqueId}))
		} else {
			var callbackName = this.createCallbacks()
			this.$hlsEl = $(this.hlsTemplate({cid: this.hlsCid, baseUrl: this.rtmp.baseUrl, playbackId: this.hlsUniqueId, callbackName: `window.Clappr.flashlsCallbacks.${this.hlsCid}`}))
			
			if(Browser.isFirefox) {
				this.$hlsEl.attr('data-hls', '')
			} else if (Browser.isIE) {
				this.$hlsEl.attr('embed').remove()
			}
		}
		
		//this.el.id = this.cid //?????
		this.$hlsEl.append(style)
		this.hlsEl = this.$hlsEl[0]
		this.$el.append(this.$hlsEl)
	}

  render() {
  	this.$el.html('')
  	this.hlsRender()
  	this.rtmpRender()

  	//this.$el.html

    /*
    //if(Browser.isLegacyIE) {
    //  this.setupIE()
    //} else {
      var callbackName = this.createCallbacks()
      var divEl = $(this.template({cid: this.hlsCid, baseUrl: this.baseUrl, playbackId: this.uniqueId, callbackName: `window.Clappr.flashlsCallbacks.${this.hlsCid}`})).attr('id', this.hlsCid)

      this.$el.html(divEl)

      this.RTMP.render()
      this.$el.append(this.RTMP.el)
      this.rtmpEl = this.RTMP.el

      console.log(this.rtmpEl)
      
      //if(Browser.isFirefox) {
      //  this.setupFirefox()
      //} else if (Browser.isIE) {
      //  this.$('embed').remove()
      //}
    //}
    this.el.id = this.cid
    this.$el.append(style)

    this.hlsEl = divEl[0]

	*/
    window.rtmpEl = this.rtmpEl
    window.hlsEl = this.hlsEl

    window.elDebug = this.el
    return this
  }
}

RtmpHls.canPlay = function(resource, mimeType) {
	return true;

  var resourceParts = resource.split('?')[0].match(/.*\.(.*)$/) || []
  return Browser.hasFlash &&
        ((resourceParts.length > 1 && resourceParts[1] == "m3u8") ||
          mimeType === 'application/x-mpegURL' || mimeType === 'application/vnd.apple.mpegurl')
}

module.exports = window.RtmpHls = RtmpHls
